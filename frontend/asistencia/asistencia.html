<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Control de Asistencia</title>
    <link rel="stylesheet" href="asistencia.css">
    <style>
        .video-container {
            position: relative;
            width: 100%;
            height: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: var(--border-radius);
            background-color: #f0f0f0;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none; /* Always hidden, used only as source */
        }
        #lista-asistencia button {
            background: none;
            border: none;
            color: #d9534f; /* Rojo Bootstrap */
            font-size: 1.2em;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        #lista-asistencia button:hover {
            background: #f8d7da;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #lista-asistencia li {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Control de Asistencia</h1>
        <div class="button-group">
            <button id="toggleCamara" class="btn">Activar cámara</button>
            <button id="toggleDeteccion" class="btn" disabled>Desactivar detección</button>
            <button onclick="volverLobby()" class="btn btn-secondary">Volver</button>
        </div>
    </div>

    <div class="container">
        <div class="card video-container">
            <video id="video" autoplay></video>
            <canvas id="canvas"></canvas>
            <div class="status"></div>
                <div id="nombreDetectado">Esperando detección...</div>
                <div id="nivelConfianza" style="font-size: 0.9em; color: #666;"></div>
            </div>
        </div>
        <div class="card attendance-container">
            <h2>Usuarios presentes</h2>
            <ul id="lista-asistencia" class="attendance-list"></ul>
        </div>
    </div>

    <script>
        let asistencia = [];
        const nombreDiv = document.getElementById('nombreDetectado');
        const confianzaDiv = document.getElementById('nivelConfianza');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let stream = null;
        let ws = null;
        let detectando = false;
        let mostrarDetecciones = true;
        
        // Ajustar canvas al tamaño de su contenedor
        function ajustarCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight - 60; // Resta espacio para el status
        }
        
        // Llamar a la función al cargar y redimensionar la ventana
        window.addEventListener('load', ajustarCanvas);
        window.addEventListener('resize', ajustarCanvas);
        
        // Buffer para almacenar detecciones de múltiples caras en 3 segundos
        let faceBuffers = {}; // Un buffer para cada cara detectada, indexado por nombre
        let bufferStartTime = null;
        const BUFFER_DURATION = 1500; // Reducido a 1.5 segundos (antes era 3000ms)
        const CONFIDENCE_THRESHOLD = 0.3; // Umbral de confianza reducido para detección más rápida (antes 0.5)

        const toggleCamaraBtn = document.getElementById('toggleCamara');
        const toggleDeteccionBtn = document.getElementById('toggleDeteccion');

        // Obtener el id de la sesión desde la URL
        const params = new URLSearchParams(window.location.search);
        const sesionId = params.get('id');

        // Agregar una función para obtener los asistentes de la sesión actual desde el backend

        async function obtenerAsistentesBackend() {
            if (!sesionId) {
                console.error("No hay ID de sesión");
                return [];
            }
            
            try {
                const response = await fetch(`/sesiones/${sesionId}`);
                if (response.ok) {
                    const data = await response.json();
                    return data.asistentes || [];
                } else {
                    console.error("Error al obtener asistentes:", await response.text());
                    return [];
                }
            } catch (error) {
                console.error("Error al recuperar asistentes:", error);
                return [];
            }
        }

        async function eliminarAsistenciaBackend(nombre) {
            if (!sesionId) {
                console.error("No hay ID de sesión");
                return false;
            }
            try {
                const response = await fetch(`/sesiones/${sesionId}/asistencia`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ nombre })
                });
                return response.ok;
            } catch (error) {
                console.error("Error al eliminar asistencia:", error);
                return false;
            }
        }

        // Modificar la función cargarAsistencia para usar los datos del backend
        async function cargarAsistencia() {
            // Obtener los datos actualizados del backend
            const asistentesBackend = await obtenerAsistentesBackend();
            
            // Actualizar la lista local con los datos del backend
            asistencia = asistentesBackend.map(asistente => ({
                nombre: asistente.nombre,
                fecha: new Date(asistente.fecha).toLocaleString()
            }));
            
            // Actualizar el conjunto de caras ya detectadas
            asistencia.forEach(item => detectedFaces.add(item.nombre));
            
            // Actualizar la interfaz
            const lista = document.getElementById('lista-asistencia');
            lista.innerHTML = '';
            asistencia.forEach(item => {
                const li = document.createElement('li');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'name';
                nameSpan.textContent = item.nombre;
                
                const timeSpan = document.createElement('span');
                timeSpan.className = 'time';
                timeSpan.textContent = item.fecha;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '❌';
                deleteBtn.className = 'btn btn-danger btn-sm';
                deleteBtn.style.marginLeft = '10px';
                deleteBtn.onclick = async () => {
                    if (confirm(`¿Eliminar a ${item.nombre} de la asistencia?`)) {
                        const exito = await eliminarAsistenciaBackend(item.nombre);
                        if (exito) {
                            // Quitar de la lista local y recargar
                            asistencia = asistencia.filter(a => a.nombre !== item.nombre);
                            cargarAsistencia();
                        } else {
                            alert('No se pudo eliminar del backend.');
                        }
                    }
                };
                
                li.appendChild(nameSpan);
                li.appendChild(timeSpan);
                li.appendChild(deleteBtn);
                lista.appendChild(li);
            });
        }
        
        // Función para procesar el buffer de detecciones para una cara específica
        function procesarBufferCara(nombre, detecciones) {
            if (detecciones.length === 0) return null;

            // Calcular el nivel de confianza como porcentaje
            const nivelConfianza = detecciones.length / (BUFFER_DURATION / 1000);
            const porcentajeConfianza = Math.round((nivelConfianza / 3) * 100); // Ajustar a un máximo de 3 detecciones por segundo

            return {
                nombre: nombre,
                confianza: nivelConfianza,
                porcentaje: porcentajeConfianza
            };
        }
        
        // Función para procesar el buffer de detecciones para una cara específica
        function procesarBufferCara(nombre, detecciones) {
            if (detecciones.length === 0) return null;
            
            // Calcular el nivel de confianza como porcentaje
            const nivelConfianza = detecciones.length / (BUFFER_DURATION / 1000);
            const porcentajeConfianza = Math.round((nivelConfianza / 3) * 100); // Ajustar a un máximo de 3 detecciones por segundo
            
            return {
                nombre: nombre,
                confianza: nivelConfianza,
                porcentaje: porcentajeConfianza
            };
        }
        
        let detectedFaces = new Set(); // Para almacenar nombres de rostros ya registrados

        // Función para procesar todos los buffers
        function procesarBuffers() {
            if (Object.keys(faceBuffers).length === 0) return;
            
            const resultados = [];
            
            // Procesar cada cara detectada
            for (const [nombre, buffer] of Object.entries(faceBuffers)) {
                if (nombre !== "Desconocido" && !detectedFaces.has(nombre)) {
                    const resultado = procesarBufferCara(nombre, buffer);
                    if (resultado && resultado.confianza > CONFIDENCE_THRESHOLD) {
                        resultados.push(resultado);
                    }
                }
            }
            
            // Mostrar resultados
            if (resultados.length > 0) {
                // Crear mensaje con todas las caras detectadas
                const nombresDetectados = resultados.map(r => r.nombre).join(", ");
                nombreDiv.textContent = `Detectados: ${nombresDetectados}`;
                
                // Mostrar confianza promedio
                const confianzaPromedio = Math.round(resultados.reduce((acc, r) => acc + r.porcentaje, 0) / resultados.length);
                confianzaDiv.textContent = `Nivel de confianza promedio: ${confianzaPromedio}%`;
                
                // Registrar asistencia para cada cara con suficiente confianza
                resultados.forEach(resultado => {
                    if (resultado.confianza > CONFIDENCE_THRESHOLD) {
                        const yaRegistrado = asistencia.some(item => item.nombre === resultado.nombre);
                        if (!yaRegistrado) {
                            // Agregar a la lista local
                            const nuevaAsistencia = {
                                nombre: resultado.nombre,
                                fecha: new Date().toLocaleString()
                            };
                            asistencia.push(nuevaAsistencia);
                            
                            // Actualizar la lista visualmente de inmediato
                            actualizarListaUI(nuevaAsistencia);
                            
                            // Marcar este rostro como ya procesado
                            detectedFaces.add(resultado.nombre);
                            
                            // Enviar al backend para guardar en la sesión
                            registrarAsistenciaBackend(resultado.nombre)
                                .then(exito => {
                                    if (!exito) {
                                        console.warn(`No se pudo guardar en la base de datos: ${resultado.nombre}`);
                                    }
                                });
                        }
                    }
                });
            } else {
                nombreDiv.textContent = "Ninguna cara identificada con confianza suficiente";
                confianzaDiv.textContent = "";
            }

            // Limpiar buffers
            faceBuffers = {};
            bufferStartTime = null;
        }

        // Nueva función para actualizar la UI inmediatamente sin esperar al backend
        function actualizarListaUI(nuevoItem) {
            const lista = document.getElementById('lista-asistencia');
            const li = document.createElement('li');
            const nameSpan = document.createElement('span');
            nameSpan.className = 'name';
            nameSpan.textContent = nuevoItem.nombre;
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'time';
            timeSpan.textContent = nuevoItem.fecha;

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '❌';
            deleteBtn.className = 'btn btn-danger btn-sm';
            deleteBtn.style.marginLeft = '10px';
            deleteBtn.onclick = async () => {
                if (confirm(`¿Eliminar a ${nuevoItem.nombre} de la asistencia?`)) {
                    const exito = await eliminarAsistenciaBackend(nuevoItem.nombre);
                    if (exito) {
                        // Quitar de la lista local y recargar
                        asistencia = asistencia.filter(a => a.nombre !== nuevoItem.nombre);
                        detectedFaces.delete(nuevoItem.nombre); // También quitar del conjunto de detectados
                        cargarAsistencia();
                    } else {
                        alert('No se pudo eliminar del backend.');
                    }
                }
            };
            
            li.appendChild(nameSpan);
            li.appendChild(timeSpan);
            li.appendChild(deleteBtn);
            
            // Añadir la animación de entrada
            li.style.animation = 'fadeIn 0.3s ease-in';
            lista.appendChild(li);
        }

        async function registrarAsistenciaBackend(nombre) {
            if (!sesionId) {
                console.error("No hay ID de sesión");
                return false;
            }
            
            try {
                const response = await fetch(`/sesiones/${sesionId}/asistencia`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        nombre: nombre,
                        fecha: new Date().toISOString()
                    })
                });
                
                if (response.ok) {
                    return true;
                } else {
                    console.error("Error al registrar asistencia:", await response.text());
                    return false;
                }
            } catch (error) {
                console.error("Error al enviar asistencia:", error);
                return false;
            }
        }

        toggleCamaraBtn.onclick = async function() {
            if (!detectando) {
                // Activar cámara
                detectando = true;
                nombreDiv.textContent = "Esperando detección...";
                confianzaDiv.textContent = "";
                toggleCamaraBtn.textContent = "Desactivar cámara";
                toggleCamaraBtn.classList.add("btn-danger");
                toggleDeteccionBtn.disabled = false;

                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } 
                    });
                    video.srcObject = stream;

                    // Dibujar el video en el canvas continuamente
                    const renderCanvas = () => {
                        if (detectando) {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            requestAnimationFrame(renderCanvas);
                        }
                    };
                    renderCanvas();

                    ws = new WebSocket("ws://localhost:8000/ws");
                    ws.onopen = () => {
                        const enviarFrame = setInterval(() => {
                            if (!detectando) {
                                clearInterval(enviarFrame);
                                return;
                            }
                            const imageData = canvas.toDataURL("image/jpeg");
                            ws.send(JSON.stringify({
                                image: imageData
                            }));
                        }, 500); // Enviar cada 500ms en lugar de 1000ms para detección más rápida
                    };

                    ws.onmessage = (event) => {
                        const detecciones = JSON.parse(event.data);

                        if (detecciones.length === 0) {
                            nombreDiv.textContent = "Nadie detectado";
                            confianzaDiv.textContent = "";
                        } else {
                            // Iniciar el temporizador para el buffer si no está activo
                            if (!bufferStartTime) {
                                bufferStartTime = Date.now();
                            }
                            
                            // Procesar todas las caras detectadas
                            detecciones.forEach(d => {
                                const [top, right, bottom, left] = d.coordenadas;
                                const yaRegistrado = detectedFaces.has(d.nombre);
                                
                                // Dibujar rectángulo y nombre en el canvas si mostrarDetecciones está activo
                                if (mostrarDetecciones) {
                                    // Cambiar el color según si ya está registrado
                                    ctx.strokeStyle = yaRegistrado ? "green" : "red";
                                    ctx.lineWidth = 2;
                                    ctx.strokeRect(left, top, right - left, bottom - top);
                                    
                                    // Texto con prefijo si ya está registrado
                                    ctx.fillStyle = yaRegistrado ? "green" : "#ff9900";
                                    ctx.font = "18px Arial";
                                    ctx.fillText(
                                        yaRegistrado ? `✓ ${d.nombre}` : d.nombre, 
                                        left + 5, 
                                        top - 5
                                    );
                                }
                                
                                // Solo añadir al buffer si no está ya registrado
                                if (d.nombre !== "Desconocido" && !yaRegistrado) {
                                    if (!faceBuffers[d.nombre]) {
                                        faceBuffers[d.nombre] = [];
                                    }
                                    faceBuffers[d.nombre].push(d.nombre);
                                }
                            });
                            
                            // Actualizar texto con todas las caras detectadas, indicando cuáles ya están registradas
                            const nombresFormateados = detecciones.map(d => 
                                detectedFaces.has(d.nombre) ? `✓ ${d.nombre}` : d.nombre
                            ).join(", ");
                            
                            nombreDiv.textContent = `Detectando: ${nombresFormateados}`;
                            
                            // Verificar si han pasado los segundos necesarios
                            if (Date.now() - bufferStartTime >= BUFFER_DURATION) {
                                procesarBuffers();
                            }
                        }
                    };

                    ws.onerror = () => {
                        nombreDiv.textContent = "❌ Error de conexión con el servidor.";
                        confianzaDiv.textContent = "";
                        detectando = false;
                        desactivarCamara();
                    };

                } catch (e) {
                    alert('No se pudo acceder a la cámara');
                    nombreDiv.textContent = "❌ No se pudo acceder a la cámara.";
                    confianzaDiv.textContent = "";
                    detectando = false;
                    desactivarCamara();
                }
            } else {
                // Desactivar cámara
                desactivarCamara();
            }
        };

        function desactivarCamara() {
            detectando = false;
            toggleCamaraBtn.textContent = "Activar cámara";
            toggleCamaraBtn.classList.remove("btn-danger");
            toggleDeteccionBtn.disabled = true;
            nombreDiv.textContent = "Cámara desactivada";
            confianzaDiv.textContent = "";

            // Procesar cualquier detección pendiente en los buffers
            if (Object.keys(faceBuffers).length > 0) {
                procesarBuffers();
            }

            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                stream = null;
            }

            if (ws) {
                ws.close();
                ws = null;
            }

            // Limpiar el canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        toggleDeteccionBtn.onclick = function() {
            mostrarDetecciones = !mostrarDetecciones;
            toggleDeteccionBtn.textContent = mostrarDetecciones ? "Desactivar detección" : "Activar detección";
        };

        function volverLobby() {
            window.location.href = "../lobby/lobby.html";
        }

        // Llamar a cargarAsistencia cuando la página se carga y también cuando cambia la lista local
        document.addEventListener('DOMContentLoaded', () => {
            cargarAsistencia();
        });
    </script>
</body>
</html>